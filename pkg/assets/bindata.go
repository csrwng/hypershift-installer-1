// Code generated by go-bindata.
// sources:
// assets/cluster-bootstrap/cluster-ingresscontrollers-02-config.yaml
// assets/cluster-bootstrap/namespace-security-allocation-controller-clusterrole.yaml
// assets/cluster-bootstrap/namespace-security-allocation-controller-clusterrolebinding.yaml
// assets/common/service-network-admin-kubeconfig-secret.yaml
// assets/control-plane-operator/cp-operator-configmap.yaml
// assets/etcd/etcd-cluster-crd.yaml
// assets/etcd/etcd-cluster.yaml
// assets/etcd/etcd-operator-cluster-role-binding.yaml
// assets/etcd/etcd-operator-cluster-role.yaml
// assets/etcd/etcd-operator.yaml
// assets/etcd/etcd-secret-template.yaml
// assets/hypershift-operator/hypershift-operator-configmap.yaml
// assets/hypershift-operator/hypershift-operator-deployment.yaml
// assets/ignition/files/etc/crio/crio.conf
// assets/ignition/files/etc/kubernetes/apiserver-proxy-config/haproxy.cfg.template
// assets/ignition/files/etc/kubernetes/kubelet.conf.template
// assets/ignition/files/etc/kubernetes/manifests/kube-apiserver-proxy.yaml.template
// assets/ignition/files/etc/sysctl.d/forward.conf
// assets/ignition/files/etc/sysctl.d/inotify.conf
// assets/ignition/files/etc/tmpfiles.d/cleanup-cni.conf
// assets/ignition/files/usr/local/bin/setup-apiserver-ip.sh.template
// assets/ignition/files/usr/local/bin/teardown-apiserver-ip.sh.template
// assets/ignition/units/apiserver-ip.service
// assets/ignition/units/kubelet.service
// assets/ignition-deployment.yaml
// assets/ignition-route.yaml
// assets/ignition-service.yaml
// assets/kube-apiserver/client.conf
// assets/kube-apiserver/kube-apiserver-configmap.yaml
// assets/kube-apiserver/kube-apiserver-deployment-patch.yaml
// assets/kube-apiserver/kube-apiserver-secret.yaml
// assets/kube-apiserver/kube-apiserver-vpnclient-config.yaml
// assets/kube-apiserver/kube-apiserver-vpnclient-secret.yaml
// assets/kube-controller-manager/kube-controller-manager-configmap.yaml
// assets/kube-controller-manager/kube-controller-manager-secret.yaml
// assets/kube-scheduler/kube-scheduler-secret.yaml
// assets/oauth-openshift/ingress-certs-secret.yaml
// assets/oauth-openshift/oauth-server-configmap.yaml
// assets/oauth-openshift/oauth-server-secret.yaml
// assets/openshift-apiserver/openshift-apiserver-configmap.yaml
// assets/openshift-apiserver/openshift-apiserver-secret.yaml
// assets/openshift-controller-manager/openshift-controller-manager-configmap.yaml
// assets/openshift-controller-manager/openshift-controller-manager-secret.yaml
// assets/openvpn/Dockerfile
// assets/openvpn/client.conf
// assets/openvpn/openvpn-ccd-configmap.yaml
// assets/openvpn/openvpn-client-configmap.yaml
// assets/openvpn/openvpn-client-deployment.yaml
// assets/openvpn/openvpn-client-secret.yaml
// assets/openvpn/openvpn-server-configmap.yaml
// assets/openvpn/openvpn-server-deployment.yaml
// assets/openvpn/openvpn-server-secret.yaml
// assets/openvpn/openvpn-server-service.yaml
// assets/openvpn/openvpn-serviceaccount.yaml
// assets/openvpn/server.conf
// assets/openvpn/worker
// assets/registry/cluster-imageregistry-config.yaml
// assets/router-proxy/client.conf
// assets/router-proxy/haproxy.cfg
// assets/router-proxy/router-proxy-configmap.yaml
// assets/router-proxy/router-proxy-deployment.yaml
// assets/router-proxy/router-proxy-http-service.yaml
// assets/router-proxy/router-proxy-https-service.yaml
// assets/router-proxy/router-proxy-vpnclient-configmap.yaml
// assets/router-proxy/router-proxy-vpnclient-secret.yaml
// assets/user-manifests-bootstrapper/user-manifest-template.yaml
// assets/user-manifests-bootstrapper/user-manifests-bootstrapper-pod.yaml
// DO NOT EDIT!

package assets

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

func (fi bindataFileInfo) Name() string {
	return fi.name
}
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}
func (fi bindataFileInfo) IsDir() bool {
	return false
}
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _clusterBootstrapClusterIngresscontrollers02ConfigYaml = []byte(`apiVersion: operator.openshift.io/v1
kind: IngressController
metadata:
  name: default
  namespace: openshift-ingress-operator
spec:
  endpointPublishingStrategy:
    type: Private
  defaultCertificate:
    name: default-ingress-cert
status: {}
`)

func clusterBootstrapClusterIngresscontrollers02ConfigYamlBytes() ([]byte, error) {
	return _clusterBootstrapClusterIngresscontrollers02ConfigYaml, nil
}

func clusterBootstrapClusterIngresscontrollers02ConfigYaml() (*asset, error) {
	bytes, err := clusterBootstrapClusterIngresscontrollers02ConfigYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "cluster-bootstrap/cluster-ingresscontrollers-02-config.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _clusterBootstrapNamespaceSecurityAllocationControllerClusterroleYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
  creationTimestamp: null
  name: system:openshift:controller:namespace-security-allocation-controller
rules:
- apiGroups:
  - security.openshift.io
  resources:
  - rangeallocations
  verbs:
  - create
  - get
  - update
- apiGroups:
  - ""
  resources:
  - namespaces
  verbs:
  - get
  - list
  - update
  - watch
  - patch
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
  - update
`)

func clusterBootstrapNamespaceSecurityAllocationControllerClusterroleYamlBytes() ([]byte, error) {
	return _clusterBootstrapNamespaceSecurityAllocationControllerClusterroleYaml, nil
}

func clusterBootstrapNamespaceSecurityAllocationControllerClusterroleYaml() (*asset, error) {
	bytes, err := clusterBootstrapNamespaceSecurityAllocationControllerClusterroleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "cluster-bootstrap/namespace-security-allocation-controller-clusterrole.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _clusterBootstrapNamespaceSecurityAllocationControllerClusterrolebindingYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
  creationTimestamp: null
  name: system:openshift:controller:namespace-security-allocation-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:openshift:controller:namespace-security-allocation-controller
subjects:
- kind: ServiceAccount
  name: namespace-security-allocation-controller
  namespace: openshift-infra
`)

func clusterBootstrapNamespaceSecurityAllocationControllerClusterrolebindingYamlBytes() ([]byte, error) {
	return _clusterBootstrapNamespaceSecurityAllocationControllerClusterrolebindingYaml, nil
}

func clusterBootstrapNamespaceSecurityAllocationControllerClusterrolebindingYaml() (*asset, error) {
	bytes, err := clusterBootstrapNamespaceSecurityAllocationControllerClusterrolebindingYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "cluster-bootstrap/namespace-security-allocation-controller-clusterrolebinding.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _commonServiceNetworkAdminKubeconfigSecretYaml = []byte(`apiVersion: v1
kind: Secret
metadata:
  name: service-network-admin-kubeconfig
data:
  kubeconfig: {{ pki "internal-admin.kubeconfig" }}
`)

func commonServiceNetworkAdminKubeconfigSecretYamlBytes() ([]byte, error) {
	return _commonServiceNetworkAdminKubeconfigSecretYaml, nil
}

func commonServiceNetworkAdminKubeconfigSecretYaml() (*asset, error) {
	bytes, err := commonServiceNetworkAdminKubeconfigSecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "common/service-network-admin-kubeconfig-secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _controlPlaneOperatorCpOperatorConfigmapYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  name: control-plane-operator
data:
  initial-ca.crt: |
{{ include_pki "combined-ca.crt"  4 }}
`)

func controlPlaneOperatorCpOperatorConfigmapYamlBytes() ([]byte, error) {
	return _controlPlaneOperatorCpOperatorConfigmapYaml, nil
}

func controlPlaneOperatorCpOperatorConfigmapYaml() (*asset, error) {
	bytes, err := controlPlaneOperatorCpOperatorConfigmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "control-plane-operator/cp-operator-configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _etcdEtcdClusterCrdYaml = []byte(`apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: etcdclusters.etcd.database.coreos.com
spec:
  conversion:
    strategy: None
  group: etcd.database.coreos.com
  names:
    kind: EtcdCluster
    listKind: EtcdClusterList
    plural: etcdclusters
    shortNames:
    - etcd
    singular: etcdcluster
  scope: Namespaced
  version: v1beta2
  versions:
  - name: v1beta2
    served: true
    storage: true
`)

func etcdEtcdClusterCrdYamlBytes() ([]byte, error) {
	return _etcdEtcdClusterCrdYaml, nil
}

func etcdEtcdClusterCrdYaml() (*asset, error) {
	bytes, err := etcdEtcdClusterCrdYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "etcd/etcd-cluster-crd.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _etcdEtcdClusterYaml = []byte(`apiVersion: etcd.database.coreos.com/v1beta2
kind: EtcdCluster
metadata:
  name: etcd
spec:
  size: 1
  version: "3.2.13"
  TLS:
    static:
      member:
        peerSecret: etcd-peer-tls
        serverSecret: etcd-server-tls
      operatorSecret: etcd-client-tls
`)

func etcdEtcdClusterYamlBytes() ([]byte, error) {
	return _etcdEtcdClusterYaml, nil
}

func etcdEtcdClusterYaml() (*asset, error) {
	bytes, err := etcdEtcdClusterYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "etcd/etcd-cluster.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _etcdEtcdOperatorClusterRoleBindingYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: etcd-operator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: etcd-operator
subjects:
- kind: ServiceAccount
  name: etcd-operator
  namespace: {{ .Namespace }}
`)

func etcdEtcdOperatorClusterRoleBindingYamlBytes() ([]byte, error) {
	return _etcdEtcdOperatorClusterRoleBindingYaml, nil
}

func etcdEtcdOperatorClusterRoleBindingYaml() (*asset, error) {
	bytes, err := etcdEtcdOperatorClusterRoleBindingYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "etcd/etcd-operator-cluster-role-binding.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _etcdEtcdOperatorClusterRoleYaml = []byte(`apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  name: etcd-operator
rules:
- apiGroups:
  - etcd.database.coreos.com
  resources:
  - etcdclusters
  - etcdbackups
  - etcdrestores
  verbs:
  - "*"
- apiGroups:
  - apiextensions.k8s.io
  resources:
  - customresourcedefinitions
  verbs:
  - "*"
- apiGroups:
  - ""
  resources:
  - pods
  - services
  - endpoints
  - persistentvolumeclaims
  - events
  verbs:
  - "*"
- apiGroups:
  - apps
  resources:
  - deployments
  verbs:
  - "*"
# The following permissions can be removed if not using S3 backup and TLS
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
`)

func etcdEtcdOperatorClusterRoleYamlBytes() ([]byte, error) {
	return _etcdEtcdOperatorClusterRoleYaml, nil
}

func etcdEtcdOperatorClusterRoleYaml() (*asset, error) {
	bytes, err := etcdEtcdOperatorClusterRoleYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "etcd/etcd-operator-cluster-role.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _etcdEtcdOperatorYaml = []byte(`---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: etcd-operator
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: etcd-operator
spec:
  replicas: 1
  selector:
    matchLabels:
      name: etcd-operator
  template:
    metadata:
      labels:
        name: etcd-operator
{{ if .RestartDate }}
      annotations:
        openshift.io/restartedAt: "{{ .RestartDate }}"
{{ end }}
    spec:
      serviceAccountName: etcd-operator
      containers:
      - name: etcd-operator
        image: quay.io/coreos/etcd-operator:v0.9.4
        command:
        - etcd-operator
        env:
        - name: MY_POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: MY_POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
`)

func etcdEtcdOperatorYamlBytes() ([]byte, error) {
	return _etcdEtcdOperatorYaml, nil
}

func etcdEtcdOperatorYaml() (*asset, error) {
	bytes, err := etcdEtcdOperatorYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "etcd/etcd-operator.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _etcdEtcdSecretTemplateYaml = []byte(`kind: Secret
apiVersion: v1
metadata:
  name: {{ .file }}-tls
data:
  {{ .secret }}.crt: {{ pki (print .file ".crt") }}
  {{ .secret }}.key: {{ pki (print .file ".key") }}
  {{ .secret }}-ca.crt: {{ pki "root-ca.crt" }}
`)

func etcdEtcdSecretTemplateYamlBytes() ([]byte, error) {
	return _etcdEtcdSecretTemplateYaml, nil
}

func etcdEtcdSecretTemplateYaml() (*asset, error) {
	bytes, err := etcdEtcdSecretTemplateYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "etcd/etcd-secret-template.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _hypershiftOperatorHypershiftOperatorConfigmapYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  name: hypershift-operator
data:
  initial-ca.crt: |
{{ include_pki "combined-ca.crt"  4 }}
`)

func hypershiftOperatorHypershiftOperatorConfigmapYamlBytes() ([]byte, error) {
	return _hypershiftOperatorHypershiftOperatorConfigmapYaml, nil
}

func hypershiftOperatorHypershiftOperatorConfigmapYaml() (*asset, error) {
	bytes, err := hypershiftOperatorHypershiftOperatorConfigmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "hypershift-operator/hypershift-operator-configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _hypershiftOperatorHypershiftOperatorDeploymentYaml = []byte(`---
apiVersion: v1
kind: ServiceAccount
metadata:
    name: hypershift-operator
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: hypershift-operator
rules:
- apiGroups:
  - ""
  resources:
  - configmaps
  - pods
  verbs:
  - get
  - patch
  - update
  - create
  - list
  - watch
- apiGroups: ["extensions", "apps"]
  resources:
  - deployments
  verbs:
  - get
  - patch
  - update
  - list
  - watch
- apiGroups:
  - route.openshift.io
  resources:
  - routes
  - routes/custom-host
  verbs:
  - get
  - list
  - watch
  - patch
  - update
  - create
  - delete
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: hypershift-operator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: hypershift-operator
subjects:
  - kind: ServiceAccount
    name: hypershift-operator
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hypershift-operator
spec:
  replicas: 1
  selector:
    matchLabels:
      app: hypershift-operator
  template:
    metadata:
      labels:
        app: hypershift-operator
{{ if .RestartDate }}
      annotations:
        openshift.io/restartedAt: "{{ .RestartDate }}"
{{ end }}
    spec:
      tolerations:
        - key: "multi-az-worker"
          operator: "Equal"
          value: "true"
          effect: NoSchedule
      containers:
      - image: {{ .HypershiftOperatorImage }}
        imagePullPolicy: IfNotPresent
        name: hypershift-operator
        env:
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: OPENSHIFT_RELEASE_VERSION
          value: {{ version "release" }}
        - name: KUBERNETES_VERSION
          value: {{ version "kubernetes" }}
        command:
        - "/usr/bin/hypershift-operator"
        - "--initial-ca-file=/etc/kubernetes/config/initial-ca.crt"
        - "--target-kubeconfig=/etc/kubernetes/kubeconfig/kubeconfig"
        - "--namespace"
        - "$(POD_NAMESPACE)"{{range $controller := .HypershiftOperatorControllers }}
        - "--controllers={{$controller}}"{{end}}
{{ if .HypershiftOperatorResources }}
        resources:{{ range .HypershiftOperatorResources }}{{ range .ResourceRequest }}
          requests: {{ if .CPU }}
            cpu: {{ .CPU }}{{ end }}{{ if .Memory }}
            memory: {{ .Memory }}{{ end }}{{ end }}{{ range .ResourceLimit }}
          limits: {{ if .CPU }}
            cpu: {{ .CPU }}{{ end }}{{ if .Memory }}
            memory: {{ .Memory }}{{ end }}{{ end }}{{ end }}
{{ end }}
        volumeMounts:
        - mountPath: /etc/kubernetes/kubeconfig
          name: kubeconfig
        - mountPath: /etc/kubernetes/config
          name: config
      restartPolicy: Always
      serviceAccountName: hypershift-operator
      volumes:
      - name: kubeconfig
        secret:
          secretName: service-network-admin-kubeconfig
      - name: config
        configMap:
          name: hypershift-operator
`)

func hypershiftOperatorHypershiftOperatorDeploymentYamlBytes() ([]byte, error) {
	return _hypershiftOperatorHypershiftOperatorDeploymentYaml, nil
}

func hypershiftOperatorHypershiftOperatorDeploymentYaml() (*asset, error) {
	bytes, err := hypershiftOperatorHypershiftOperatorDeploymentYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "hypershift-operator/hypershift-operator-deployment.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionFilesEtcCrioCrioConf = []byte(`[crio]

# The default log directory where all logs will go unless directly specified by
# the kubelet. The log directory specified must be an absolute directory.
log_dir = "/var/log/crio/pods"

# Location for CRI-O to lay down the version file
version_file = "/var/lib/crio/version"

# The crio.api table contains settings for the kubelet/gRPC interface.
[crio.api]

# Path to AF_LOCAL socket on which CRI-O will listen.
listen = "/var/run/crio/crio.sock"

# Host IP considered as the primary IP to use by CRI-O for things such as host network IP.
host_ip = ""

# IP address on which the stream server will listen.
stream_address = ""

# The port on which the stream server will listen.
stream_port = "10010"

# Enable encrypted TLS transport of the stream server.
stream_enable_tls = false

# Path to the x509 certificate file used to serve the encrypted stream. This
# file can change, and CRI-O will automatically pick up the changes within 5
# minutes.
stream_tls_cert = ""

# Path to the key file used to serve the encrypted stream. This file can
# change and CRI-O will automatically pick up the changes within 5 minutes.
stream_tls_key = ""

# Path to the x509 CA(s) file used to verify and authenticate client
# communication with the encrypted stream. This file can change and CRI-O will
# automatically pick up the changes within 5 minutes.
stream_tls_ca = ""

# Maximum grpc send message size in bytes. If not set or <=0, then CRI-O will default to 16 * 1024 * 1024.
grpc_max_send_msg_size = 16777216

# Maximum grpc receive message size. If not set or <= 0, then CRI-O will default to 16 * 1024 * 1024.
grpc_max_recv_msg_size = 16777216

# The crio.runtime table contains settings pertaining to the OCI runtime used
# and options for how to set up and manage the OCI runtime.
[crio.runtime]

# default_runtime is the _name_ of the OCI runtime to be used as the default.
# The name is matched against the runtimes map below.
default_runtime = "runc"

# If true, the runtime will not use pivot_root, but instead use MS_MOVE.
no_pivot = false

# Path to the conmon binary, used for monitoring the OCI runtime.
# Will be searched for using $PATH if empty.
conmon = "/usr/libexec/crio/conmon"

# Cgroup setting for conmon
conmon_cgroup = "pod"

# Environment variable list for the conmon process, used for passing necessary
# environment variables to conmon or the runtime.
conmon_env = [
    "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
]

# If true, SELinux will be used for pod separation on the host.
selinux = true

# Path to the seccomp.json profile which is used as the default seccomp profile
# for the runtime. If not specified, then the internal default seccomp profile
# will be used.
seccomp_profile = ""

# Used to change the name of the default AppArmor profile of CRI-O. The default
# profile name is "crio-default-" followed by the version string of CRI-O.
apparmor_profile = "crio-default"

# Cgroup management implementation used for the runtime.
cgroup_manager = "systemd"

# List of default capabilities for containers. If it is empty or commented out,
# only the capabilities defined in the containers json file by the user/kube
# will be added.
default_capabilities = [
    "CHOWN",
    "DAC_OVERRIDE",
    "FSETID",
    "FOWNER",
    "NET_RAW",
    "SETGID",
    "SETUID",
    "SETPCAP",
    "NET_BIND_SERVICE",
    "SYS_CHROOT",
    "KILL",
]

# List of default sysctls. If it is empty or commented out, only the sysctls
# defined in the container json file by the user/kube will be added.
default_sysctls = [
]

# List of additional devices. specified as
# "<device-on-host>:<device-on-container>:<permissions>", for example: "--device=/dev/sdc:/dev/xvdc:rwm".
#If it is empty or commented out, only the devices
# defined in the container json file by the user/kube will be added.
additional_devices = [
]

# Path to OCI hooks directories for automatically executed hooks.
hooks_dir = [
    "/etc/containers/oci/hooks.d",
]

# List of default mounts for each container. **Deprecated:** this option will
# be removed in future versions in favor of default_mounts_file.
default_mounts = [
]

# Maximum number of processes allowed in a container.
pids_limit = 1024

# Maximum sized allowed for the container log file. Negative numbers indicate
# that no size limit is imposed. If it is positive, it must be >= 8192 to
# match/exceed conmon's read buffer. The file is truncated and re-opened so the
# limit is never exceeded.
log_size_max = -1

# Whether container output should be logged to journald in addition to the kuberentes log file
log_to_journald = false

# Path to directory in which container exit files are written to by conmon.
container_exits_dir = "/var/run/crio/exits"

# Path to directory for container attach sockets.
container_attach_socket_dir = "/var/run/crio"

# The prefix to use for the source of the bind mounts.
bind_mount_prefix = ""

# If set to true, all containers will run in read-only mode.
read_only = false

# Changes the verbosity of the logs based on the level it is set to. Options
# are fatal, panic, error, warn, info, and debug. This option supports live
# configuration reload.
log_level = "error"

# The UID mappings for the user namespace of each container. A range is
# specified in the form containerUID:HostUID:Size. Multiple ranges must be
# separated by comma.
uid_mappings = ""

# The GID mappings for the user namespace of each container. A range is
# specified in the form containerGID:HostGID:Size. Multiple ranges must be
# separated by comma.
gid_mappings = ""

# The minimal amount of time in seconds to wait before issuing a timeout
# regarding the proper termination of the container.
ctr_stop_timeout = 0

# ManageNetworkNSLifecycle determines whether we pin and remove network namespace
# and manage its lifecycle.
manage_network_ns_lifecycle = false

# The "crio.runtime.runtimes" table defines a list of OCI compatible runtimes.
# The runtime to use is picked based on the runtime_handler provided by the CRI.
# If no runtime_handler is provided, the runtime will be picked based on the level
# of trust of the workload. Each entry in the table should follow the format:
#
#[crio.runtime.runtimes.runtime-handler]
#  runtime_path = "/path/to/the/executable"
#  runtime_type = "oci"
#  runtime_root = "/path/to/the/root"
#
# Where:
# - runtime-handler: name used to identify the runtime
# - runtime_path (optional, string): absolute path to the runtime executable in
#   the host filesystem. If omitted, the runtime-handler identifier should match
#   the runtime executable name, and the runtime executable should be placed
#   in $PATH.
# - runtime_type (optional, string): type of runtime, one of: "oci", "vm". If
#   omitted, an "oci" runtime is assumed.
# - runtime_root (optional, string): root directory for storage of containers
#   state.
[crio.runtime.runtimes.runc]
runtime_path = ""
runtime_type = "oci"
runtime_root = "/run/runc"

# CRI-O reads its configured registries defaults from the system wide
# containers-registries.conf(5) located in /etc/containers/registries.conf. If
# you want to modify just CRI-O, you can change the registries configuration in
# this file. Otherwise, leave insecure_registries and registries commented out to
# use the system's defaults from /etc/containers/registries.conf.
[crio.image]

# Default transport for pulling images from a remote container storage.
default_transport = "docker://"

# The path to a file containing credentials necessary for pulling images from
# secure registries. The file is similar to that of /var/lib/kubelet/config.json
global_auth_file = "/var/lib/kubelet/config.json"

# The image used to instantiate infra containers.
# This option supports live configuration reload.
pause_image = "quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:81f373ff297b9a56cd53e174e8a2f76717700db4f85ca1b793db996f08c1b108"

# The path to a file containing credentials specific for pulling the pause_image from
# above. The file is similar to that of /var/lib/kubelet/config.json
# This option supports live configuration reload.
pause_image_auth_file = "/var/lib/kubelet/config.json"

# The command to run to have a container stay in the paused state.
# When explicitly set to "", it will fallback to the entrypoint and command
# specified in the pause image. When commented out, it will fallback to the
# default: "/pause". This option supports live configuration reload.
pause_command = "/usr/bin/pod"

# Path to the file which decides what sort of policy we use when deciding
# whether or not to trust an image that we've pulled. It is not recommended that
# this option be used, as the default behavior of using the system-wide default
# policy (i.e., /etc/containers/policy.json) is most often preferred. Please
# refer to containers-policy.json(5) for more details.
signature_policy = ""

# Controls how image volumes are handled. The valid values are mkdir, bind and
# ignore; the latter will ignore volumes entirely.
image_volumes = "mkdir"

# The crio.network table containers settings pertaining to the management of
# CNI plugins.
[crio.network]
# Path to the directory where CNI configuration files are located.
network_dir = "/etc/kubernetes/cni/net.d/"

# Paths to directories where CNI plugin binaries are located.
plugin_dirs = [
    "/var/lib/cni/bin",
]

# A necessary configuration for Prometheus based metrics retrieval
[crio.metrics]

# Globally enable or disable metrics support.
enable_metrics = true

# The port on which the metrics server will listen.
metrics_port = 9537
`)

func ignitionFilesEtcCrioCrioConfBytes() ([]byte, error) {
	return _ignitionFilesEtcCrioCrioConf, nil
}

func ignitionFilesEtcCrioCrioConf() (*asset, error) {
	bytes, err := ignitionFilesEtcCrioCrioConfBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition/files/etc/crio/crio.conf", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionFilesEtcKubernetesApiserverProxyConfigHaproxyCfgTemplate = []byte(`global
  maxconn 7000

defaults
  mode tcp
  timeout client 10m
  timeout server 10m
  timeout connect 10s
  timeout client-fin 5s
  timeout server-fin 5s
  timeout queue 5s
  retries 3

frontend local_apiserver
  bind {{ .ExternalAPIAddress }}:6443
  default_backend remote_apiserver

backend remote_apiserver
  mode tcp
  server controlplane {{ .ExternalAPIDNSName }}:{{ .ExternalAPIPort }}
`)

func ignitionFilesEtcKubernetesApiserverProxyConfigHaproxyCfgTemplateBytes() ([]byte, error) {
	return _ignitionFilesEtcKubernetesApiserverProxyConfigHaproxyCfgTemplate, nil
}

func ignitionFilesEtcKubernetesApiserverProxyConfigHaproxyCfgTemplate() (*asset, error) {
	bytes, err := ignitionFilesEtcKubernetesApiserverProxyConfigHaproxyCfgTemplateBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition/files/etc/kubernetes/apiserver-proxy-config/haproxy.cfg.template", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionFilesEtcKubernetesKubeletConfTemplate = []byte(`kind: KubeletConfiguration
apiVersion: kubelet.config.k8s.io/v1beta1
authentication:
  x509:
    clientCAFile: /etc/kubernetes/ca.crt
  anonymous:
    enabled: false
cgroupDriver: systemd
clusterDNS:
  - {{ cidrPrefix .ServiceCIDR }}.0.10
clusterDomain: cluster.local
featureGates:
  RotateKubeletServerCertificate: true
runtimeRequestTimeout: 10m
serializeImagePulls: false
serverTLSBootstrap: true
staticPodPath: /etc/kubernetes/manifests
`)

func ignitionFilesEtcKubernetesKubeletConfTemplateBytes() ([]byte, error) {
	return _ignitionFilesEtcKubernetesKubeletConfTemplate, nil
}

func ignitionFilesEtcKubernetesKubeletConfTemplate() (*asset, error) {
	bytes, err := ignitionFilesEtcKubernetesKubeletConfTemplateBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition/files/etc/kubernetes/kubelet.conf.template", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionFilesEtcKubernetesManifestsKubeApiserverProxyYamlTemplate = []byte(`apiVersion: v1
kind: Pod
metadata:
  name: kube-apiserver-proxy
  namespace: kube-system
  labels:
    k8s-app: kube-apiserver-proxy
spec:
  hostNetwork: true
  containers:
  - name: haproxy
    image: {{ imageFor "haproxy-router" }}
    livenessProbe:
      failureThreshold: 3
      initialDelaySeconds: 120
      periodSeconds: 120
      successThreshold: 1
      tcpSocket:
        host: {{ .ExternalAPIAddress }}
        port: 6443
      timeoutSeconds: 60
    command:
    - haproxy
    - -f
    - /usr/local/etc/haproxy/haproxy.cfg
    volumeMounts:
    - name: config
      mountPath: /usr/local/etc/haproxy
  volumes:
  - name: config
    hostPath:
      path: /etc/kubernetes/apiserver-proxy-config
`)

func ignitionFilesEtcKubernetesManifestsKubeApiserverProxyYamlTemplateBytes() ([]byte, error) {
	return _ignitionFilesEtcKubernetesManifestsKubeApiserverProxyYamlTemplate, nil
}

func ignitionFilesEtcKubernetesManifestsKubeApiserverProxyYamlTemplate() (*asset, error) {
	bytes, err := ignitionFilesEtcKubernetesManifestsKubeApiserverProxyYamlTemplateBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition/files/etc/kubernetes/manifests/kube-apiserver-proxy.yaml.template", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionFilesEtcSysctlDForwardConf = []byte(`net.ipv4.ip_forward = 1
`)

func ignitionFilesEtcSysctlDForwardConfBytes() ([]byte, error) {
	return _ignitionFilesEtcSysctlDForwardConf, nil
}

func ignitionFilesEtcSysctlDForwardConf() (*asset, error) {
	bytes, err := ignitionFilesEtcSysctlDForwardConfBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition/files/etc/sysctl.d/forward.conf", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionFilesEtcSysctlDInotifyConf = []byte(`
fs.inotify.max_user_watches = 65536
fs.inotify.max_user_instances = 8192
`)

func ignitionFilesEtcSysctlDInotifyConfBytes() ([]byte, error) {
	return _ignitionFilesEtcSysctlDInotifyConf, nil
}

func ignitionFilesEtcSysctlDInotifyConf() (*asset, error) {
	bytes, err := ignitionFilesEtcSysctlDInotifyConfBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition/files/etc/sysctl.d/inotify.conf", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionFilesEtcTmpfilesDCleanupCniConf = []byte(`r /etc/kubernetes/cni/net.d/80-openshift-network.conf
r /etc/kubernetes/cni/net.d/10-ovn-kubernetes.conf
r /etc/kubernetes/cni/net.d/00-multus.conf
d /run/multus/cni/net.d/ 0755 root root - -
`)

func ignitionFilesEtcTmpfilesDCleanupCniConfBytes() ([]byte, error) {
	return _ignitionFilesEtcTmpfilesDCleanupCniConf, nil
}

func ignitionFilesEtcTmpfilesDCleanupCniConf() (*asset, error) {
	bytes, err := ignitionFilesEtcTmpfilesDCleanupCniConfBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition/files/etc/tmpfiles.d/cleanup-cni.conf", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionFilesUsrLocalBinSetupApiserverIpShTemplate = []byte(`#!/usr/bin/env bash
set -x
ip addr add {{ .ExternalAPIAddress }}/32 brd {{ .ExternalAPIAddress }} scope host dev lo
ip route add {{ .ExternalAPIAddress }}/32 dev lo scope link src {{ .ExternalAPIAddress }}
`)

func ignitionFilesUsrLocalBinSetupApiserverIpShTemplateBytes() ([]byte, error) {
	return _ignitionFilesUsrLocalBinSetupApiserverIpShTemplate, nil
}

func ignitionFilesUsrLocalBinSetupApiserverIpShTemplate() (*asset, error) {
	bytes, err := ignitionFilesUsrLocalBinSetupApiserverIpShTemplateBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition/files/usr/local/bin/setup-apiserver-ip.sh.template", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionFilesUsrLocalBinTeardownApiserverIpShTemplate = []byte(`#!/usr/bin/env bash
set -x
ip addr delete {{ .ExternalAPIAddress }}/32 dev lo
ip route del {{ .ExternalAPIAddress }}/32 dev lo scope link src {{ .ExternalAPIAddress }}
`)

func ignitionFilesUsrLocalBinTeardownApiserverIpShTemplateBytes() ([]byte, error) {
	return _ignitionFilesUsrLocalBinTeardownApiserverIpShTemplate, nil
}

func ignitionFilesUsrLocalBinTeardownApiserverIpShTemplate() (*asset, error) {
	bytes, err := ignitionFilesUsrLocalBinTeardownApiserverIpShTemplateBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition/files/usr/local/bin/teardown-apiserver-ip.sh.template", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionUnitsApiserverIpService = []byte(`[Unit]
Description=Sets up local IP to proxy API server requests
Wants=network-online.target
After=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/setup-apiserver-ip.sh
ExecStop=/usr/local/bin/teardown-apiserver-ip.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
`)

func ignitionUnitsApiserverIpServiceBytes() ([]byte, error) {
	return _ignitionUnitsApiserverIpService, nil
}

func ignitionUnitsApiserverIpService() (*asset, error) {
	bytes, err := ignitionUnitsApiserverIpServiceBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition/units/apiserver-ip.service", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionUnitsKubeletService = []byte(`[Unit]
Description=Kubernetes Kubelet
Documentation=https://github.com/kubernetes/kubernetes
After=crio.service
Requires=crio.service

[Service]
ExecStartPre=/bin/mkdir -p /etc/kubernetes/manifests
ExecStart=/usr/bin/hyperkube kubelet \
  --config=/etc/kubernetes/kubelet.conf \
  --container-runtime=remote \
  --container-runtime-endpoint=/var/run/crio/crio.sock \
  --bootstrap-kubeconfig=/etc/kubernetes/kubeconfig \
  --kubeconfig=/var/lib/kubelet/kubeconfig \
  --node-labels=node-role.kubernetes.io/worker,node-role.kubernetes.io/master \
  --v=2
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
`)

func ignitionUnitsKubeletServiceBytes() ([]byte, error) {
	return _ignitionUnitsKubeletService, nil
}

func ignitionUnitsKubeletService() (*asset, error) {
	bytes, err := ignitionUnitsKubeletServiceBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition/units/kubelet.service", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionDeploymentYaml = []byte(`apiVersion: apps/v1
kind: Deployment
metadata:
  name: ignition-config
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ignition-provider
  template:
    metadata:
      labels:
        app: ignition-provider
    spec:
      containers:
      - args:
        - -m
        - http.server
        - --directory
        - /assets
        command:
        - /usr/local/bin/python
        image: docker.io/python:latest
        name: python
        ports:
        - containerPort: 8000
          name: web-server
          protocol: TCP
        resources:
          requests:
            cpu: 10m
            memory: 150Mi
        volumeMounts:
        - mountPath: /assets
          name: ignition-config
      volumes:
      - configMap:
          defaultMode: 420
          name: ignition-config
        name: ignition-config
`)

func ignitionDeploymentYamlBytes() ([]byte, error) {
	return _ignitionDeploymentYaml, nil
}

func ignitionDeploymentYaml() (*asset, error) {
	bytes, err := ignitionDeploymentYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition-deployment.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionRouteYaml = []byte(`apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: ignition-provider
spec:
  to:
    kind: Service
    name: ignition-provider
`)

func ignitionRouteYamlBytes() ([]byte, error) {
	return _ignitionRouteYaml, nil
}

func ignitionRouteYaml() (*asset, error) {
	bytes, err := ignitionRouteYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition-route.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _ignitionServiceYaml = []byte(`apiVersion: v1
kind: Service
metadata:
  name: ignition-provider
spec:
  ports:
  - name: http
    port: 80
    protocol: TCP
    targetPort: 8000
  selector:
    app: ignition-provider
  type: ClusterIP
`)

func ignitionServiceYamlBytes() ([]byte, error) {
	return _ignitionServiceYaml, nil
}

func ignitionServiceYaml() (*asset, error) {
	bytes, err := ignitionServiceYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "ignition-service.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _kubeApiserverClientConf = []byte(`client
verb 3
nobind
dev tun
remote-cert-tls server
remote openvpn-server 1194 tcp
ca secret/ca.crt
cert secret/tls.crt
key secret/tls.key
`)

func kubeApiserverClientConfBytes() ([]byte, error) {
	return _kubeApiserverClientConf, nil
}

func kubeApiserverClientConf() (*asset, error) {
	bytes, err := kubeApiserverClientConfBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "kube-apiserver/client.conf", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _kubeApiserverKubeApiserverConfigmapYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  name: kube-apiserver
data:
  aggregator-client-ca.crt: |-
{{ include_pki "root-ca.crt" 4 }}
  kubelet-client-ca.crt: |-
{{ include_pki "combined-ca.crt" 4 }}
  service-account.pub: |-
{{ include_pki "service-account.pub" 4 }}
  serving-ca.crt: |-
{{ include_pki "combined-ca.crt" 4 }}
  etcd-ca.crt: |-
{{ include_pki "root-ca.crt" 4 }}
`)

func kubeApiserverKubeApiserverConfigmapYamlBytes() ([]byte, error) {
	return _kubeApiserverKubeApiserverConfigmapYaml, nil
}

func kubeApiserverKubeApiserverConfigmapYaml() (*asset, error) {
	bytes, err := kubeApiserverKubeApiserverConfigmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "kube-apiserver/kube-apiserver-configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _kubeApiserverKubeApiserverDeploymentPatchYaml = []byte(`- op: add
  path: /spec/template/spec/containers/0/securityContext
  value:
    runAsUser: 1001
    capabilities:
      drop:
      - MKNOD
      - NET_ADMIN
- op: add
  path: /spec/template/spec/volumes/-
  value:
    name: vpnconfig
    configMap:
      name: kube-apiserver-vpnclient-config
- op: add
  path: /spec/template/spec/volumes/-
  value:
    name: vpnsecret
    secret:
      secretName: kube-apiserver-vpnclient-secret
- op: add
  path: /spec/template/spec/serviceAccountName
  value: vpn
- op: add
  path: /spec/template/spec/containers/-
  value:
    name: openvpn-client
    image: quay.io/hypershift/openvpn:latest
    imagePullPolicy: Always
    command:
    - /usr/sbin/openvpn
    args:
    - --config
    - /etc/openvpn/config/client.conf
    workingDir: /etc/openvpn/
    securityContext:
      privileged: true
    volumeMounts:
    - mountPath: /etc/openvpn/secret
      name: vpnsecret
    - mountPath: /etc/openvpn/config
      name: vpnconfig
`)

func kubeApiserverKubeApiserverDeploymentPatchYamlBytes() ([]byte, error) {
	return _kubeApiserverKubeApiserverDeploymentPatchYaml, nil
}

func kubeApiserverKubeApiserverDeploymentPatchYaml() (*asset, error) {
	bytes, err := kubeApiserverKubeApiserverDeploymentPatchYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "kube-apiserver/kube-apiserver-deployment-patch.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _kubeApiserverKubeApiserverSecretYaml = []byte(`apiVersion: v1
kind: Secret
metadata:
  name: kube-apiserver
data:
  server.crt: {{ pki "kube-apiserver-server.crt" }}
  server.key: {{ pki "kube-apiserver-server.key" }}
  kubelet-client.crt: {{ pki "kube-apiserver-kubelet.crt" }}
  kubelet-client.key: {{ pki "kube-apiserver-kubelet.key" }}
  etcd-client.crt: {{ pki "etcd-client.crt" }}
  etcd-client.key: {{ pki "etcd-client.key" }}
  proxy-client.crt: {{ pki "kube-apiserver-aggregator-proxy-client.crt" }}
  proxy-client.key: {{ pki "kube-apiserver-aggregator-proxy-client.key" }}
`)

func kubeApiserverKubeApiserverSecretYamlBytes() ([]byte, error) {
	return _kubeApiserverKubeApiserverSecretYaml, nil
}

func kubeApiserverKubeApiserverSecretYaml() (*asset, error) {
	bytes, err := kubeApiserverKubeApiserverSecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "kube-apiserver/kube-apiserver-secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _kubeApiserverKubeApiserverVpnclientConfigYaml = []byte(`kind: ConfigMap
apiVersion: v1
metadata:
  name: kube-apiserver-vpnclient-config
data:
  client.conf: |-
{{ include "kube-apiserver/client.conf" 4 }}
`)

func kubeApiserverKubeApiserverVpnclientConfigYamlBytes() ([]byte, error) {
	return _kubeApiserverKubeApiserverVpnclientConfigYaml, nil
}

func kubeApiserverKubeApiserverVpnclientConfigYaml() (*asset, error) {
	bytes, err := kubeApiserverKubeApiserverVpnclientConfigYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "kube-apiserver/kube-apiserver-vpnclient-config.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _kubeApiserverKubeApiserverVpnclientSecretYaml = []byte(`kind: Secret
apiVersion: v1
metadata:
  name: kube-apiserver-vpnclient-secret
data:
  tls.crt: {{ pki "openvpn-kube-apiserver-client.crt" }}
  tls.key: {{ pki "openvpn-kube-apiserver-client.key" }}
  ca.crt: {{ pki "openvpn-ca.crt" }}
`)

func kubeApiserverKubeApiserverVpnclientSecretYamlBytes() ([]byte, error) {
	return _kubeApiserverKubeApiserverVpnclientSecretYaml, nil
}

func kubeApiserverKubeApiserverVpnclientSecretYaml() (*asset, error) {
	bytes, err := kubeApiserverKubeApiserverVpnclientSecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "kube-apiserver/kube-apiserver-vpnclient-secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _kubeControllerManagerKubeControllerManagerConfigmapYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  name: kube-controller-manager
data:
  root-ca.crt: |-
{{ include_pki "combined-ca.crt" 4 }}
  service-ca.crt: |-
{{ include_pki "combined-ca.crt" 4 }}
`)

func kubeControllerManagerKubeControllerManagerConfigmapYamlBytes() ([]byte, error) {
	return _kubeControllerManagerKubeControllerManagerConfigmapYaml, nil
}

func kubeControllerManagerKubeControllerManagerConfigmapYaml() (*asset, error) {
	bytes, err := kubeControllerManagerKubeControllerManagerConfigmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "kube-controller-manager/kube-controller-manager-configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _kubeControllerManagerKubeControllerManagerSecretYaml = []byte(`apiVersion: v1
kind: Secret
metadata:
  name: kube-controller-manager
data:
  kubeconfig: {{ pki "internal-admin.kubeconfig" }}
  service-account.key: {{ pki "service-account.key" }}
  cluster-signer.crt: {{ pki "cluster-signer.crt" }}
  cluster-signer.key: {{ pki "cluster-signer.key" }}
`)

func kubeControllerManagerKubeControllerManagerSecretYamlBytes() ([]byte, error) {
	return _kubeControllerManagerKubeControllerManagerSecretYaml, nil
}

func kubeControllerManagerKubeControllerManagerSecretYaml() (*asset, error) {
	bytes, err := kubeControllerManagerKubeControllerManagerSecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "kube-controller-manager/kube-controller-manager-secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _kubeSchedulerKubeSchedulerSecretYaml = []byte(`kind: Secret
apiVersion: v1
metadata:
  name: kube-scheduler
data:
  kubeconfig: {{ pki "internal-admin.kubeconfig" }}
`)

func kubeSchedulerKubeSchedulerSecretYamlBytes() ([]byte, error) {
	return _kubeSchedulerKubeSchedulerSecretYaml, nil
}

func kubeSchedulerKubeSchedulerSecretYaml() (*asset, error) {
	bytes, err := kubeSchedulerKubeSchedulerSecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "kube-scheduler/kube-scheduler-secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _oauthOpenshiftIngressCertsSecretYaml = []byte(`apiVersion: v1
kind: Secret
metadata:
  name: default-ingress-cert
  namespace: openshift-ingress
data:
  tls.crt: {{ pki "ingress-openshift.crt" }}
  tls.key: {{ pki "ingress-openshift.key" }}
`)

func oauthOpenshiftIngressCertsSecretYamlBytes() ([]byte, error) {
	return _oauthOpenshiftIngressCertsSecretYaml, nil
}

func oauthOpenshiftIngressCertsSecretYaml() (*asset, error) {
	bytes, err := oauthOpenshiftIngressCertsSecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "oauth-openshift/ingress-certs-secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _oauthOpenshiftOauthServerConfigmapYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  name: oauth-openshift
data:
  ca.crt: |-
{{ include_pki "combined-ca.crt" 4 }}
`)

func oauthOpenshiftOauthServerConfigmapYamlBytes() ([]byte, error) {
	return _oauthOpenshiftOauthServerConfigmapYaml, nil
}

func oauthOpenshiftOauthServerConfigmapYaml() (*asset, error) {
	bytes, err := oauthOpenshiftOauthServerConfigmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "oauth-openshift/oauth-server-configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _oauthOpenshiftOauthServerSecretYaml = []byte(`apiVersion: v1
kind: Secret
metadata:
  name: oauth-openshift
data:
  kubeconfig: {{ pki "internal-admin.kubeconfig" }}
  server.crt: {{ pki "ingress-openshift.crt" }}
  server.key: {{ pki "ingress-openshift.key" }}
`)

func oauthOpenshiftOauthServerSecretYamlBytes() ([]byte, error) {
	return _oauthOpenshiftOauthServerSecretYaml, nil
}

func oauthOpenshiftOauthServerSecretYaml() (*asset, error) {
	bytes, err := oauthOpenshiftOauthServerSecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "oauth-openshift/oauth-server-secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openshiftApiserverOpenshiftApiserverConfigmapYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  name: openshift-apiserver
data:
  aggregator-client-ca.crt: |-
{{ include_pki "root-ca.crt" 4 }}
  etcd-ca.crt: |-
{{ include_pki "root-ca.crt" 4 }}
  serving-ca.crt: |- 
{{ include_pki "root-ca.crt" 4 }}
`)

func openshiftApiserverOpenshiftApiserverConfigmapYamlBytes() ([]byte, error) {
	return _openshiftApiserverOpenshiftApiserverConfigmapYaml, nil
}

func openshiftApiserverOpenshiftApiserverConfigmapYaml() (*asset, error) {
	bytes, err := openshiftApiserverOpenshiftApiserverConfigmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openshift-apiserver/openshift-apiserver-configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openshiftApiserverOpenshiftApiserverSecretYaml = []byte(`apiVersion: v1
kind: Secret
metadata:
  name: openshift-apiserver
data:
  kubeconfig: {{ pki "internal-admin.kubeconfig" }}
  server.crt: {{ pki "openshift-apiserver-server.crt" }}
  server.key: {{ pki "openshift-apiserver-server.key" }}
  etcd-client.crt: {{ pki "etcd-client.crt" }}
  etcd-client.key: {{ pki "etcd-client.key" }}
`)

func openshiftApiserverOpenshiftApiserverSecretYamlBytes() ([]byte, error) {
	return _openshiftApiserverOpenshiftApiserverSecretYaml, nil
}

func openshiftApiserverOpenshiftApiserverSecretYaml() (*asset, error) {
	bytes, err := openshiftApiserverOpenshiftApiserverSecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openshift-apiserver/openshift-apiserver-secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openshiftControllerManagerOpenshiftControllerManagerConfigmapYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  name: openshift-controller-manager
data:
  serving-ca.crt: |-
{{ include_pki "root-ca.crt"  4 }}
`)

func openshiftControllerManagerOpenshiftControllerManagerConfigmapYamlBytes() ([]byte, error) {
	return _openshiftControllerManagerOpenshiftControllerManagerConfigmapYaml, nil
}

func openshiftControllerManagerOpenshiftControllerManagerConfigmapYaml() (*asset, error) {
	bytes, err := openshiftControllerManagerOpenshiftControllerManagerConfigmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openshift-controller-manager/openshift-controller-manager-configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openshiftControllerManagerOpenshiftControllerManagerSecretYaml = []byte(`apiVersion: v1
kind: Secret
metadata:
  name: openshift-controller-manager
data:
  kubeconfig: {{ pki "internal-admin.kubeconfig" }}
  server.crt: {{ pki "openshift-controller-manager-server.crt" }}
  server.key: {{ pki "openshift-controller-manager-server.key" }}
`)

func openshiftControllerManagerOpenshiftControllerManagerSecretYamlBytes() ([]byte, error) {
	return _openshiftControllerManagerOpenshiftControllerManagerSecretYaml, nil
}

func openshiftControllerManagerOpenshiftControllerManagerSecretYaml() (*asset, error) {
	bytes, err := openshiftControllerManagerOpenshiftControllerManagerSecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openshift-controller-manager/openshift-controller-manager-secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openvpnDockerfile = []byte(`FROM registry.access.redhat.com/ubi7/ubi
RUN yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm && \
    yum install -y openvpn && \
    yum clean all
CMD ["/usr/sbin/openvpn"]
`)

func openvpnDockerfileBytes() ([]byte, error) {
	return _openvpnDockerfile, nil
}

func openvpnDockerfile() (*asset, error) {
	bytes, err := openvpnDockerfileBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openvpn/Dockerfile", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openvpnClientConf = []byte(`client
verb 3
nobind
dev tun
remote-cert-tls server
remote {{ .ExternalOpenVPNAddress }} {{ .ExternalOpenVPNPort }} tcp
ca ca.crt
cert tls.crt
key tls.key
`)

func openvpnClientConfBytes() ([]byte, error) {
	return _openvpnClientConf, nil
}

func openvpnClientConf() (*asset, error) {
	bytes, err := openvpnClientConfBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openvpn/client.conf", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openvpnOpenvpnCcdConfigmapYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  name: openvpn-ccd
data:
  worker: |-
{{ include "openvpn/worker" 4 }}
`)

func openvpnOpenvpnCcdConfigmapYamlBytes() ([]byte, error) {
	return _openvpnOpenvpnCcdConfigmapYaml, nil
}

func openvpnOpenvpnCcdConfigmapYaml() (*asset, error) {
	bytes, err := openvpnOpenvpnCcdConfigmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openvpn/openvpn-ccd-configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openvpnOpenvpnClientConfigmapYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  name: openvpn-client
  namespace: kube-system
data:
  client.conf: |-
{{ include "openvpn/client.conf" 4 }}
`)

func openvpnOpenvpnClientConfigmapYamlBytes() ([]byte, error) {
	return _openvpnOpenvpnClientConfigmapYaml, nil
}

func openvpnOpenvpnClientConfigmapYaml() (*asset, error) {
	bytes, err := openvpnOpenvpnClientConfigmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openvpn/openvpn-client-configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openvpnOpenvpnClientDeploymentYaml = []byte(`kind: Deployment
apiVersion: apps/v1
metadata:
  name: openvpn-client
  namespace: kube-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: openvpn-client
  template:
    metadata:
      labels:
        app: openvpn-client
    spec:
      automountServiceAccountToken: false
      containers:
      - name: openvpn-client
        image: quay.io/hypershift/openvpn:latest
        imagePullPolicy: Always
        command:
        - /bin/bash
        args:
        - -c
        - |-
          #!/bin/bash
          set -eu
          iptables -t nat -A POSTROUTING -s 192.168.255.0/24 -j MASQUERADE
          exec /usr/sbin/openvpn --config /etc/openvpn-config/client.conf
        workingDir: /etc/openvpn
        securityContext:
          privileged: true
{{ if .OpenVPNClientResources }}
        resources:{{ range .OpenVPNClientResources }}{{ range .ResourceRequest }}
          requests: {{ if .CPU }}
            cpu: {{ .CPU }}{{ end }}{{ if .Memory }}
            memory: {{ .Memory }}{{ end }}{{ end }}{{ range .ResourceLimit }}
          limits: {{ if .CPU }}
            cpu: {{ .CPU }}{{ end }}{{ if .Memory }}
            memory: {{ .Memory }}{{ end }}{{ end }}{{ end }}
{{ end }}
        volumeMounts:
        - mountPath: /etc/openvpn
          name: secret
        - mountPath: /etc/openvpn-config
          name: config
        - mountPath: /lib/modules
          name: host-modules
          readOnly: true
      volumes:
      - secret:
          secretName: openvpn-client
        name: secret
      - name: config
        configMap:
          name: openvpn-client
      - hostPath:
          path: /lib/modules
        name: host-modules
`)

func openvpnOpenvpnClientDeploymentYamlBytes() ([]byte, error) {
	return _openvpnOpenvpnClientDeploymentYaml, nil
}

func openvpnOpenvpnClientDeploymentYaml() (*asset, error) {
	bytes, err := openvpnOpenvpnClientDeploymentYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openvpn/openvpn-client-deployment.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openvpnOpenvpnClientSecretYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  name: user-manifest-openvpn-client-secret
data:
  data: |
    apiVersion: v1
    kind: Secret
    metadata:
      name: openvpn-client
      namespace: kube-system
    data:
      tls.crt: {{ pki "openvpn-worker-client.crt" }}
      tls.key: {{ pki "openvpn-worker-client.key" }}
      ca.crt: {{ pki "openvpn-ca.crt" }}
`)

func openvpnOpenvpnClientSecretYamlBytes() ([]byte, error) {
	return _openvpnOpenvpnClientSecretYaml, nil
}

func openvpnOpenvpnClientSecretYaml() (*asset, error) {
	bytes, err := openvpnOpenvpnClientSecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openvpn/openvpn-client-secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openvpnOpenvpnServerConfigmapYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  name: openvpn-server
data:
  server.conf: |-
{{ include "openvpn/server.conf" 4 }}
`)

func openvpnOpenvpnServerConfigmapYamlBytes() ([]byte, error) {
	return _openvpnOpenvpnServerConfigmapYaml, nil
}

func openvpnOpenvpnServerConfigmapYaml() (*asset, error) {
	bytes, err := openvpnOpenvpnServerConfigmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openvpn/openvpn-server-configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openvpnOpenvpnServerDeploymentYaml = []byte(`kind: Deployment
apiVersion: apps/v1
metadata:
  name: openvpn-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: openvpn-server
  template:
    metadata:
      labels:
        app: openvpn-server
{{ if .RestartDate }}
      annotations:
        openshift.io/restartedAt: "{{ .RestartDate }}"
{{ end }}
    spec:
      automountServiceAccountToken: false
      containers:
      - name: openvpn-server
        image: quay.io/hypershift/openvpn:latest
        imagePullPolicy: Always
        command:
        - /usr/sbin/openvpn
        args:
        - --config
        - /etc/openvpn/config/server.conf
        workingDir: /etc/openvpn/server
        securityContext:
          privileged: true
{{ if .OpenVPNServerResources }}
        resources:{{ range .OpenVPNServerResources }}{{ range .ResourceRequest }}
          requests: {{ if .CPU }}
            cpu: {{ .CPU }}{{ end }}{{ if .Memory }}
            memory: {{ .Memory }}{{ end }}{{ end }}{{ range .ResourceLimit }}
          limits: {{ if .CPU }}
            cpu: {{ .CPU }}{{ end }}{{ if .Memory }}
            memory: {{ .Memory }}{{ end }}{{ end }}{{ end }}
{{ end }}
        volumeMounts:
        - mountPath: /etc/openvpn/server
          name: server
        - mountPath: /etc/openvpn/ccd
          name: ccd
        - mountPath: /etc/openvpn/config
          name: config
      serviceAccountName: vpn
      volumes:
      - secret:
          secretName: openvpn-server
        name: server
      - configMap:
          name: openvpn-server
        name: config
      - configMap:
          name: openvpn-ccd
        name: ccd
`)

func openvpnOpenvpnServerDeploymentYamlBytes() ([]byte, error) {
	return _openvpnOpenvpnServerDeploymentYaml, nil
}

func openvpnOpenvpnServerDeploymentYaml() (*asset, error) {
	bytes, err := openvpnOpenvpnServerDeploymentYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openvpn/openvpn-server-deployment.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openvpnOpenvpnServerSecretYaml = []byte(`apiVersion: v1
kind: Secret
metadata:
  name: openvpn-server
data:
  tls.crt: {{ pki "openvpn-server.crt" }}
  tls.key: {{ pki "openvpn-server.key" }}
  ca.crt: {{ pki "openvpn-ca.crt" }}
  dh.pem: {{ pki "openvpn-dh.pem" }}
`)

func openvpnOpenvpnServerSecretYamlBytes() ([]byte, error) {
	return _openvpnOpenvpnServerSecretYaml, nil
}

func openvpnOpenvpnServerSecretYaml() (*asset, error) {
	bytes, err := openvpnOpenvpnServerSecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openvpn/openvpn-server-secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openvpnOpenvpnServerServiceYaml = []byte(`apiVersion: v1
kind: Service
metadata:
  name: openvpn-server
spec:
  ports:
  - port: 1194
    protocol: TCP
    targetPort: 1194
    nodePort: {{ .OpenVPNNodePort }}
  selector:
    app: openvpn-server
  type: NodePort
`)

func openvpnOpenvpnServerServiceYamlBytes() ([]byte, error) {
	return _openvpnOpenvpnServerServiceYaml, nil
}

func openvpnOpenvpnServerServiceYaml() (*asset, error) {
	bytes, err := openvpnOpenvpnServerServiceYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openvpn/openvpn-server-service.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openvpnOpenvpnServiceaccountYaml = []byte(`kind: ServiceAccount
apiVersion: v1
metadata:
  name: vpn
`)

func openvpnOpenvpnServiceaccountYamlBytes() ([]byte, error) {
	return _openvpnOpenvpnServiceaccountYaml, nil
}

func openvpnOpenvpnServiceaccountYaml() (*asset, error) {
	bytes, err := openvpnOpenvpnServiceaccountYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openvpn/openvpn-serviceaccount.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openvpnServerConf = []byte(`server 192.168.255.0 255.255.255.0
verb 3
ca ca.crt
cert tls.crt
key tls.key
dh dh.pem
#TODO figure out how to generate this without needing the openvpn command if possible
#tls-auth /etc/openvpn/pki/ta.key
#key-direction 0
keepalive 10 60
persist-key
persist-tun

proto tcp
# Rely on Docker to do port mapping, internally always 1194
port 1194
dev tun0
status /tmp/openvpn-status.log

comp-lzo no

client-config-dir /etc/openvpn/ccd

### Route Configurations Below
route {{ address .PodCIDR }} {{ mask .PodCIDR }}
route {{ address .ServiceCIDR }} {{ mask .ServiceCIDR }}


### Push Configurations Below
push "comp-lzo no"

### Extra Configurations Below
duplicate-cn
client-to-client
push "route {{ address .PodCIDR }} {{ mask .PodCIDR }}"
push "route {{ address .ServiceCIDR }} {{ mask .ServiceCIDR }}"
`)

func openvpnServerConfBytes() ([]byte, error) {
	return _openvpnServerConf, nil
}

func openvpnServerConf() (*asset, error) {
	bytes, err := openvpnServerConfBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openvpn/server.conf", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _openvpnWorker = []byte(`iroute {{ address .ServiceCIDR }} {{ mask .ServiceCIDR }}
iroute {{ address .PodCIDR }} {{ mask .PodCIDR }}
`)

func openvpnWorkerBytes() ([]byte, error) {
	return _openvpnWorker, nil
}

func openvpnWorker() (*asset, error) {
	bytes, err := openvpnWorkerBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "openvpn/worker", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _registryClusterImageregistryConfigYaml = []byte(`apiVersion: imageregistry.operator.openshift.io/v1
kind: Config
metadata:
  finalizers:
  - imageregistry.operator.openshift.io/finalizer
  name: cluster
spec:
  defaultRoute: false
  httpSecret: {{ .ImageRegistryHTTPSecret }}
  logging: 2
  managementState: Managed
  proxy:
    http: ""
    https: ""
    noProxy: ""
  readOnly: false
  replicas: 1
  requests:
    read:
      maxInQueue: 0
      maxRunning: 0
      maxWaitInQueue: 0s
    write:
      maxInQueue: 0
      maxRunning: 0
      maxWaitInQueue: 0s
  storage:
    emptyDir: {}
`)

func registryClusterImageregistryConfigYamlBytes() ([]byte, error) {
	return _registryClusterImageregistryConfigYaml, nil
}

func registryClusterImageregistryConfigYaml() (*asset, error) {
	bytes, err := registryClusterImageregistryConfigYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "registry/cluster-imageregistry-config.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _routerProxyClientConf = []byte(`client
verb 3
nobind
dev tun
remote-cert-tls server
remote openvpn-server 1194 tcp
ca secret/ca.crt
cert secret/tls.crt
key secret/tls.key
`)

func routerProxyClientConfBytes() ([]byte, error) {
	return _routerProxyClientConf, nil
}

func routerProxyClientConf() (*asset, error) {
	bytes, err := routerProxyClientConfBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "router-proxy/client.conf", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _routerProxyHaproxyCfg = []byte(`global
  maxconn 7000

defaults
  mode tcp
  timeout client 10m
  timeout server 10m
  timeout connect 10s
  timeout client-fin 5s
  timeout server-fin 5s
  timeout queue 5s
  retries 3

frontend local_router_http
  bind :8080
  default_backend remote_router_http

frontend local_router_https
  bind :8443
  default_backend remote_router_https

backend remote_router_http
  mode tcp
  server remote_http ${ROUTER_SERVICE_IP}:80

backend remote_router_https
  mode tcp
  server remote_https ${ROUTER_SERVICE_IP}:443
`)

func routerProxyHaproxyCfgBytes() ([]byte, error) {
	return _routerProxyHaproxyCfg, nil
}

func routerProxyHaproxyCfg() (*asset, error) {
	bytes, err := routerProxyHaproxyCfgBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "router-proxy/haproxy.cfg", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _routerProxyRouterProxyConfigmapYaml = []byte(`kind: ConfigMap
apiVersion: v1
metadata:
  name: router-proxy-config
data:
  haproxy.cfg: |-
{{ include "router-proxy/haproxy.cfg" 4 }}
`)

func routerProxyRouterProxyConfigmapYamlBytes() ([]byte, error) {
	return _routerProxyRouterProxyConfigmapYaml, nil
}

func routerProxyRouterProxyConfigmapYaml() (*asset, error) {
	bytes, err := routerProxyRouterProxyConfigmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "router-proxy/router-proxy-configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _routerProxyRouterProxyDeploymentYaml = []byte(`kind: Deployment
apiVersion: apps/v1
metadata:
  name: router-proxy
  labels:
    app: router-proxy
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: router-proxy
  template:
    metadata:
      labels:
        app: router-proxy
    spec:
      initContainers:
      - name: service-ip
        image: {{ imageFor "cli" }}
        env:
        - name: KUBECONFIG
          value: /etc/openshift/kubeconfig
        command:
        - /bin/bash
        args:
        - -c
        - |-
          #!/bin/bash
          while ! oc get service -n openshift-ingress router-internal-default; do
            echo "Waiting for the internal default router to be available"
            sleep 30
          done
          export ROUTER_SERVICE_IP="$(oc get service -n openshift-ingress router-internal-default -o jsonpath='{ .spec.clusterIP }')"
          sed -e "s/\${ROUTER_SERVICE_IP}/${ROUTER_SERVICE_IP}/" /config-template/haproxy.cfg > /config/haproxy.cfg
        volumeMounts:
        - name: config-template
          mountPath: /config-template
        - name: config
          mountPath: /config
        - name: kubeconfig
          mountPath: /etc/openshift
      containers:
      - name: router-proxy
        image: {{ imageFor "haproxy-router" }}
        command:
        - haproxy
        args:
        - -f
        - /usr/local/etc/haproxy/haproxy.cfg
        ports:
        - containerPort: 8443
          name: https
        - containerPort: 8080
          name: http
        securityContext:
          runAsUser: 1001
          capabilities:
            drop:
            - MKNOD
            - NET_ADMIN
        volumeMounts:
        - name: config
          mountPath: /usr/local/etc/haproxy
      - name: openvpn-client
        image: quay.io/hypershift/openvpn:latest
        imagePullPolicy: Always
        command:
        - /usr/sbin/openvpn
        args:
        - --config
        - /etc/openvpn/config/client.conf
        workingDir: /etc/openvpn/
        securityContext:
          privileged: true
        volumeMounts:
        - mountPath: /etc/openvpn/secret
          name: vpnsecret
        - mountPath: /etc/openvpn/config
          name: vpnconfig
      serviceAccountName: vpn
      volumes:
      - name: config-template
        configMap:
          name: router-proxy-config
      - name: config
        emptyDir: {}
      - name: kubeconfig
        secret:
          secretName: service-network-admin-kubeconfig
      - configMap:
          name: router-proxy-vpnclient-config
        name: vpnconfig
      - secret:
          secretName: router-proxy-vpnclient-secret
        name: vpnsecret
`)

func routerProxyRouterProxyDeploymentYamlBytes() ([]byte, error) {
	return _routerProxyRouterProxyDeploymentYaml, nil
}

func routerProxyRouterProxyDeploymentYaml() (*asset, error) {
	bytes, err := routerProxyRouterProxyDeploymentYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "router-proxy/router-proxy-deployment.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _routerProxyRouterProxyHttpServiceYaml = []byte(`kind: Service
apiVersion: v1
metadata:
  name: router-http
spec:
  ports:
  - name: http
    port: 80
    protocol: TCP
    targetPort: http
  selector:
    app: router-proxy
`)

func routerProxyRouterProxyHttpServiceYamlBytes() ([]byte, error) {
	return _routerProxyRouterProxyHttpServiceYaml, nil
}

func routerProxyRouterProxyHttpServiceYaml() (*asset, error) {
	bytes, err := routerProxyRouterProxyHttpServiceYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "router-proxy/router-proxy-http-service.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _routerProxyRouterProxyHttpsServiceYaml = []byte(`kind: Service
apiVersion: v1
metadata:
  name: router-https
spec:
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: https
  selector:
    app: router-proxy
`)

func routerProxyRouterProxyHttpsServiceYamlBytes() ([]byte, error) {
	return _routerProxyRouterProxyHttpsServiceYaml, nil
}

func routerProxyRouterProxyHttpsServiceYaml() (*asset, error) {
	bytes, err := routerProxyRouterProxyHttpsServiceYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "router-proxy/router-proxy-https-service.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _routerProxyRouterProxyVpnclientConfigmapYaml = []byte(`kind: ConfigMap
apiVersion: v1
metadata:
  name: router-proxy-vpnclient-config
data:
  client.conf: |-
{{ include "router-proxy/client.conf" 4 }}
`)

func routerProxyRouterProxyVpnclientConfigmapYamlBytes() ([]byte, error) {
	return _routerProxyRouterProxyVpnclientConfigmapYaml, nil
}

func routerProxyRouterProxyVpnclientConfigmapYaml() (*asset, error) {
	bytes, err := routerProxyRouterProxyVpnclientConfigmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "router-proxy/router-proxy-vpnclient-configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _routerProxyRouterProxyVpnclientSecretYaml = []byte(`kind: Secret
apiVersion: v1
metadata:
  name: router-proxy-vpnclient-secret
data:
  tls.crt: {{ pki "openvpn-router-proxy-client.crt" }}
  tls.key: {{ pki "openvpn-router-proxy-client.key" }}
  ca.crt: {{ pki "openvpn-ca.crt" }}
`)

func routerProxyRouterProxyVpnclientSecretYamlBytes() ([]byte, error) {
	return _routerProxyRouterProxyVpnclientSecretYaml, nil
}

func routerProxyRouterProxyVpnclientSecretYaml() (*asset, error) {
	bytes, err := routerProxyRouterProxyVpnclientSecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "router-proxy/router-proxy-vpnclient-secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _userManifestsBootstrapperUserManifestTemplateYaml = []byte(`kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ .name }}
data:
  data: |-
{{ includeData .data 4 }}
`)

func userManifestsBootstrapperUserManifestTemplateYamlBytes() ([]byte, error) {
	return _userManifestsBootstrapperUserManifestTemplateYaml, nil
}

func userManifestsBootstrapperUserManifestTemplateYaml() (*asset, error) {
	bytes, err := userManifestsBootstrapperUserManifestTemplateYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "user-manifests-bootstrapper/user-manifest-template.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _userManifestsBootstrapperUserManifestsBootstrapperPodYaml = []byte(`---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: user-manifests-bootstrapper
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: user-manifests-bootstrapper
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: edit
subjects:
  - kind: ServiceAccount
    name: user-manifests-bootstrapper
---
apiVersion: v1
kind: Pod
metadata:
  name: manifests-bootstrapper
spec:
  tolerations:
    - key: "multi-az-worker"
      operator: "Equal"
      value: "true"
      effect: NoSchedule
  initContainers:
    - image: {{ .ReleaseImage }}
      imagePullPolicy: IfNotPresent
      name: cluster-version-operator
      workingDir: /tmp
      command:
        - /bin/bash
      args:
        - -c
        - |-
          cd /tmp
          mkdir output
          /usr/bin/cluster-version-operator render --output-dir /tmp/output --release-image {{ .ReleaseImage }}
          # Exclude the CVO deployment manifest
          rm /tmp/output/manifests/0000_00_cluster-version-operator*deployment.yaml
          cp /tmp/output/manifests/* /work
      volumeMounts:
        - mountPath: /work
          name: work
    - image: {{ imageFor "cluster-config-operator" }}
      imagePullPolicy: IfNotPresent
      name: config-operator
      workingDir: /tmp
      command:
        - /bin/bash
      args:
        - -c
        - |-
          cd /tmp
          mkdir input output
          /usr/bin/cluster-config-operator render --config-output-file config --asset-input-dir /tmp/input --asset-output-dir /tmp/output
          cp /tmp/output/manifests/* /work
      volumeMounts:
        - mountPath: /work
          name: work
  containers:
    - image: {{ imageFor "cli" }}
      imagePullPolicy: IfNotPresent
      name: bootstrapper
      workingDir: /work
      command:
        - /bin/bash
      args:
        - -c
        - |-
          #!/bin/bash
          set -eu
          for name in $(oc get cm | grep '^user-manifest-' | awk '{ print $1 }'); do
             oc get cm ${name} -o jsonpath='{ .data.data }' > "${name}.yaml"
          done
          export KUBECONFIG=/etc/openshift/kubeconfig
          oc apply -f $(pwd)
          # Replace the global certs configmap here because it's too large to oc apply
          oc create configmap -n openshift-controller-manager openshift-global-ca --from-file ca-bundle.crt=/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem --dry-run -o yaml > /tmp/openshift-global-ca
          oc replace -n openshift-controller-manager -f /tmp/openshift-global-ca --force
      volumeMounts:
        - mountPath: /etc/openshift
          name: kubeconfig
          readOnly: true
        - mountPath: /work
          name: work
  restartPolicy: OnFailure
  serviceAccountName: user-manifests-bootstrapper
  volumes:
    - name: kubeconfig
      secret:
        secretName: service-network-admin-kubeconfig
    - name: work
      emptyDir: {}
`)

func userManifestsBootstrapperUserManifestsBootstrapperPodYamlBytes() ([]byte, error) {
	return _userManifestsBootstrapperUserManifestsBootstrapperPodYaml, nil
}

func userManifestsBootstrapperUserManifestsBootstrapperPodYaml() (*asset, error) {
	bytes, err := userManifestsBootstrapperUserManifestsBootstrapperPodYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "user-manifests-bootstrapper/user-manifests-bootstrapper-pod.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"cluster-bootstrap/cluster-ingresscontrollers-02-config.yaml":                        clusterBootstrapClusterIngresscontrollers02ConfigYaml,
	"cluster-bootstrap/namespace-security-allocation-controller-clusterrole.yaml":        clusterBootstrapNamespaceSecurityAllocationControllerClusterroleYaml,
	"cluster-bootstrap/namespace-security-allocation-controller-clusterrolebinding.yaml": clusterBootstrapNamespaceSecurityAllocationControllerClusterrolebindingYaml,
	"common/service-network-admin-kubeconfig-secret.yaml":                                commonServiceNetworkAdminKubeconfigSecretYaml,
	"control-plane-operator/cp-operator-configmap.yaml":                                  controlPlaneOperatorCpOperatorConfigmapYaml,
	"etcd/etcd-cluster-crd.yaml":                                                         etcdEtcdClusterCrdYaml,
	"etcd/etcd-cluster.yaml":                                                             etcdEtcdClusterYaml,
	"etcd/etcd-operator-cluster-role-binding.yaml":                                       etcdEtcdOperatorClusterRoleBindingYaml,
	"etcd/etcd-operator-cluster-role.yaml":                                               etcdEtcdOperatorClusterRoleYaml,
	"etcd/etcd-operator.yaml":                                                            etcdEtcdOperatorYaml,
	"etcd/etcd-secret-template.yaml":                                                     etcdEtcdSecretTemplateYaml,
	"hypershift-operator/hypershift-operator-configmap.yaml":                             hypershiftOperatorHypershiftOperatorConfigmapYaml,
	"hypershift-operator/hypershift-operator-deployment.yaml":                            hypershiftOperatorHypershiftOperatorDeploymentYaml,
	"ignition/files/etc/crio/crio.conf":                                                  ignitionFilesEtcCrioCrioConf,
	"ignition/files/etc/kubernetes/apiserver-proxy-config/haproxy.cfg.template":          ignitionFilesEtcKubernetesApiserverProxyConfigHaproxyCfgTemplate,
	"ignition/files/etc/kubernetes/kubelet.conf.template":                                ignitionFilesEtcKubernetesKubeletConfTemplate,
	"ignition/files/etc/kubernetes/manifests/kube-apiserver-proxy.yaml.template":         ignitionFilesEtcKubernetesManifestsKubeApiserverProxyYamlTemplate,
	"ignition/files/etc/sysctl.d/forward.conf":                                           ignitionFilesEtcSysctlDForwardConf,
	"ignition/files/etc/sysctl.d/inotify.conf":                                           ignitionFilesEtcSysctlDInotifyConf,
	"ignition/files/etc/tmpfiles.d/cleanup-cni.conf":                                     ignitionFilesEtcTmpfilesDCleanupCniConf,
	"ignition/files/usr/local/bin/setup-apiserver-ip.sh.template":                        ignitionFilesUsrLocalBinSetupApiserverIpShTemplate,
	"ignition/files/usr/local/bin/teardown-apiserver-ip.sh.template":                     ignitionFilesUsrLocalBinTeardownApiserverIpShTemplate,
	"ignition/units/apiserver-ip.service":                                                ignitionUnitsApiserverIpService,
	"ignition/units/kubelet.service":                                                     ignitionUnitsKubeletService,
	"ignition-deployment.yaml":                                                           ignitionDeploymentYaml,
	"ignition-route.yaml":                                                                ignitionRouteYaml,
	"ignition-service.yaml":                                                              ignitionServiceYaml,
	"kube-apiserver/client.conf":                                                         kubeApiserverClientConf,
	"kube-apiserver/kube-apiserver-configmap.yaml":                                       kubeApiserverKubeApiserverConfigmapYaml,
	"kube-apiserver/kube-apiserver-deployment-patch.yaml":                                kubeApiserverKubeApiserverDeploymentPatchYaml,
	"kube-apiserver/kube-apiserver-secret.yaml":                                          kubeApiserverKubeApiserverSecretYaml,
	"kube-apiserver/kube-apiserver-vpnclient-config.yaml":                                kubeApiserverKubeApiserverVpnclientConfigYaml,
	"kube-apiserver/kube-apiserver-vpnclient-secret.yaml":                                kubeApiserverKubeApiserverVpnclientSecretYaml,
	"kube-controller-manager/kube-controller-manager-configmap.yaml":                     kubeControllerManagerKubeControllerManagerConfigmapYaml,
	"kube-controller-manager/kube-controller-manager-secret.yaml":                        kubeControllerManagerKubeControllerManagerSecretYaml,
	"kube-scheduler/kube-scheduler-secret.yaml":                                          kubeSchedulerKubeSchedulerSecretYaml,
	"oauth-openshift/ingress-certs-secret.yaml":                                          oauthOpenshiftIngressCertsSecretYaml,
	"oauth-openshift/oauth-server-configmap.yaml":                                        oauthOpenshiftOauthServerConfigmapYaml,
	"oauth-openshift/oauth-server-secret.yaml":                                           oauthOpenshiftOauthServerSecretYaml,
	"openshift-apiserver/openshift-apiserver-configmap.yaml":                             openshiftApiserverOpenshiftApiserverConfigmapYaml,
	"openshift-apiserver/openshift-apiserver-secret.yaml":                                openshiftApiserverOpenshiftApiserverSecretYaml,
	"openshift-controller-manager/openshift-controller-manager-configmap.yaml":           openshiftControllerManagerOpenshiftControllerManagerConfigmapYaml,
	"openshift-controller-manager/openshift-controller-manager-secret.yaml":              openshiftControllerManagerOpenshiftControllerManagerSecretYaml,
	"openvpn/Dockerfile":                                                                 openvpnDockerfile,
	"openvpn/client.conf":                                                                openvpnClientConf,
	"openvpn/openvpn-ccd-configmap.yaml":                                                 openvpnOpenvpnCcdConfigmapYaml,
	"openvpn/openvpn-client-configmap.yaml":                                              openvpnOpenvpnClientConfigmapYaml,
	"openvpn/openvpn-client-deployment.yaml":                                             openvpnOpenvpnClientDeploymentYaml,
	"openvpn/openvpn-client-secret.yaml":                                                 openvpnOpenvpnClientSecretYaml,
	"openvpn/openvpn-server-configmap.yaml":                                              openvpnOpenvpnServerConfigmapYaml,
	"openvpn/openvpn-server-deployment.yaml":                                             openvpnOpenvpnServerDeploymentYaml,
	"openvpn/openvpn-server-secret.yaml":                                                 openvpnOpenvpnServerSecretYaml,
	"openvpn/openvpn-server-service.yaml":                                                openvpnOpenvpnServerServiceYaml,
	"openvpn/openvpn-serviceaccount.yaml":                                                openvpnOpenvpnServiceaccountYaml,
	"openvpn/server.conf":                                                                openvpnServerConf,
	"openvpn/worker":                                                                     openvpnWorker,
	"registry/cluster-imageregistry-config.yaml":                                         registryClusterImageregistryConfigYaml,
	"router-proxy/client.conf":                                                           routerProxyClientConf,
	"router-proxy/haproxy.cfg":                                                           routerProxyHaproxyCfg,
	"router-proxy/router-proxy-configmap.yaml":                                           routerProxyRouterProxyConfigmapYaml,
	"router-proxy/router-proxy-deployment.yaml":                                          routerProxyRouterProxyDeploymentYaml,
	"router-proxy/router-proxy-http-service.yaml":                                        routerProxyRouterProxyHttpServiceYaml,
	"router-proxy/router-proxy-https-service.yaml":                                       routerProxyRouterProxyHttpsServiceYaml,
	"router-proxy/router-proxy-vpnclient-configmap.yaml":                                 routerProxyRouterProxyVpnclientConfigmapYaml,
	"router-proxy/router-proxy-vpnclient-secret.yaml":                                    routerProxyRouterProxyVpnclientSecretYaml,
	"user-manifests-bootstrapper/user-manifest-template.yaml":                            userManifestsBootstrapperUserManifestTemplateYaml,
	"user-manifests-bootstrapper/user-manifests-bootstrapper-pod.yaml":                   userManifestsBootstrapperUserManifestsBootstrapperPodYaml,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}

var _bintree = &bintree{nil, map[string]*bintree{
	"cluster-bootstrap": {nil, map[string]*bintree{
		"cluster-ingresscontrollers-02-config.yaml":                        {clusterBootstrapClusterIngresscontrollers02ConfigYaml, map[string]*bintree{}},
		"namespace-security-allocation-controller-clusterrole.yaml":        {clusterBootstrapNamespaceSecurityAllocationControllerClusterroleYaml, map[string]*bintree{}},
		"namespace-security-allocation-controller-clusterrolebinding.yaml": {clusterBootstrapNamespaceSecurityAllocationControllerClusterrolebindingYaml, map[string]*bintree{}},
	}},
	"common": {nil, map[string]*bintree{
		"service-network-admin-kubeconfig-secret.yaml": {commonServiceNetworkAdminKubeconfigSecretYaml, map[string]*bintree{}},
	}},
	"control-plane-operator": {nil, map[string]*bintree{
		"cp-operator-configmap.yaml": {controlPlaneOperatorCpOperatorConfigmapYaml, map[string]*bintree{}},
	}},
	"etcd": {nil, map[string]*bintree{
		"etcd-cluster-crd.yaml":                   {etcdEtcdClusterCrdYaml, map[string]*bintree{}},
		"etcd-cluster.yaml":                       {etcdEtcdClusterYaml, map[string]*bintree{}},
		"etcd-operator-cluster-role-binding.yaml": {etcdEtcdOperatorClusterRoleBindingYaml, map[string]*bintree{}},
		"etcd-operator-cluster-role.yaml":         {etcdEtcdOperatorClusterRoleYaml, map[string]*bintree{}},
		"etcd-operator.yaml":                      {etcdEtcdOperatorYaml, map[string]*bintree{}},
		"etcd-secret-template.yaml":               {etcdEtcdSecretTemplateYaml, map[string]*bintree{}},
	}},
	"hypershift-operator": {nil, map[string]*bintree{
		"hypershift-operator-configmap.yaml":  {hypershiftOperatorHypershiftOperatorConfigmapYaml, map[string]*bintree{}},
		"hypershift-operator-deployment.yaml": {hypershiftOperatorHypershiftOperatorDeploymentYaml, map[string]*bintree{}},
	}},
	"ignition": {nil, map[string]*bintree{
		"files": {nil, map[string]*bintree{
			"etc": {nil, map[string]*bintree{
				"crio": {nil, map[string]*bintree{
					"crio.conf": {ignitionFilesEtcCrioCrioConf, map[string]*bintree{}},
				}},
				"kubernetes": {nil, map[string]*bintree{
					"apiserver-proxy-config": {nil, map[string]*bintree{
						"haproxy.cfg.template": {ignitionFilesEtcKubernetesApiserverProxyConfigHaproxyCfgTemplate, map[string]*bintree{}},
					}},
					"kubelet.conf.template": {ignitionFilesEtcKubernetesKubeletConfTemplate, map[string]*bintree{}},
					"manifests": {nil, map[string]*bintree{
						"kube-apiserver-proxy.yaml.template": {ignitionFilesEtcKubernetesManifestsKubeApiserverProxyYamlTemplate, map[string]*bintree{}},
					}},
				}},
				"sysctl.d": {nil, map[string]*bintree{
					"forward.conf": {ignitionFilesEtcSysctlDForwardConf, map[string]*bintree{}},
					"inotify.conf": {ignitionFilesEtcSysctlDInotifyConf, map[string]*bintree{}},
				}},
				"tmpfiles.d": {nil, map[string]*bintree{
					"cleanup-cni.conf": {ignitionFilesEtcTmpfilesDCleanupCniConf, map[string]*bintree{}},
				}},
			}},
			"usr": {nil, map[string]*bintree{
				"local": {nil, map[string]*bintree{
					"bin": {nil, map[string]*bintree{
						"setup-apiserver-ip.sh.template":    {ignitionFilesUsrLocalBinSetupApiserverIpShTemplate, map[string]*bintree{}},
						"teardown-apiserver-ip.sh.template": {ignitionFilesUsrLocalBinTeardownApiserverIpShTemplate, map[string]*bintree{}},
					}},
				}},
			}},
		}},
		"units": {nil, map[string]*bintree{
			"apiserver-ip.service": {ignitionUnitsApiserverIpService, map[string]*bintree{}},
			"kubelet.service":      {ignitionUnitsKubeletService, map[string]*bintree{}},
		}},
	}},
	"ignition-deployment.yaml": {ignitionDeploymentYaml, map[string]*bintree{}},
	"ignition-route.yaml":      {ignitionRouteYaml, map[string]*bintree{}},
	"ignition-service.yaml":    {ignitionServiceYaml, map[string]*bintree{}},
	"kube-apiserver": {nil, map[string]*bintree{
		"client.conf":                          {kubeApiserverClientConf, map[string]*bintree{}},
		"kube-apiserver-configmap.yaml":        {kubeApiserverKubeApiserverConfigmapYaml, map[string]*bintree{}},
		"kube-apiserver-deployment-patch.yaml": {kubeApiserverKubeApiserverDeploymentPatchYaml, map[string]*bintree{}},
		"kube-apiserver-secret.yaml":           {kubeApiserverKubeApiserverSecretYaml, map[string]*bintree{}},
		"kube-apiserver-vpnclient-config.yaml": {kubeApiserverKubeApiserverVpnclientConfigYaml, map[string]*bintree{}},
		"kube-apiserver-vpnclient-secret.yaml": {kubeApiserverKubeApiserverVpnclientSecretYaml, map[string]*bintree{}},
	}},
	"kube-controller-manager": {nil, map[string]*bintree{
		"kube-controller-manager-configmap.yaml": {kubeControllerManagerKubeControllerManagerConfigmapYaml, map[string]*bintree{}},
		"kube-controller-manager-secret.yaml":    {kubeControllerManagerKubeControllerManagerSecretYaml, map[string]*bintree{}},
	}},
	"kube-scheduler": {nil, map[string]*bintree{
		"kube-scheduler-secret.yaml": {kubeSchedulerKubeSchedulerSecretYaml, map[string]*bintree{}},
	}},
	"oauth-openshift": {nil, map[string]*bintree{
		"ingress-certs-secret.yaml":   {oauthOpenshiftIngressCertsSecretYaml, map[string]*bintree{}},
		"oauth-server-configmap.yaml": {oauthOpenshiftOauthServerConfigmapYaml, map[string]*bintree{}},
		"oauth-server-secret.yaml":    {oauthOpenshiftOauthServerSecretYaml, map[string]*bintree{}},
	}},
	"openshift-apiserver": {nil, map[string]*bintree{
		"openshift-apiserver-configmap.yaml": {openshiftApiserverOpenshiftApiserverConfigmapYaml, map[string]*bintree{}},
		"openshift-apiserver-secret.yaml":    {openshiftApiserverOpenshiftApiserverSecretYaml, map[string]*bintree{}},
	}},
	"openshift-controller-manager": {nil, map[string]*bintree{
		"openshift-controller-manager-configmap.yaml": {openshiftControllerManagerOpenshiftControllerManagerConfigmapYaml, map[string]*bintree{}},
		"openshift-controller-manager-secret.yaml":    {openshiftControllerManagerOpenshiftControllerManagerSecretYaml, map[string]*bintree{}},
	}},
	"openvpn": {nil, map[string]*bintree{
		"Dockerfile":                     {openvpnDockerfile, map[string]*bintree{}},
		"client.conf":                    {openvpnClientConf, map[string]*bintree{}},
		"openvpn-ccd-configmap.yaml":     {openvpnOpenvpnCcdConfigmapYaml, map[string]*bintree{}},
		"openvpn-client-configmap.yaml":  {openvpnOpenvpnClientConfigmapYaml, map[string]*bintree{}},
		"openvpn-client-deployment.yaml": {openvpnOpenvpnClientDeploymentYaml, map[string]*bintree{}},
		"openvpn-client-secret.yaml":     {openvpnOpenvpnClientSecretYaml, map[string]*bintree{}},
		"openvpn-server-configmap.yaml":  {openvpnOpenvpnServerConfigmapYaml, map[string]*bintree{}},
		"openvpn-server-deployment.yaml": {openvpnOpenvpnServerDeploymentYaml, map[string]*bintree{}},
		"openvpn-server-secret.yaml":     {openvpnOpenvpnServerSecretYaml, map[string]*bintree{}},
		"openvpn-server-service.yaml":    {openvpnOpenvpnServerServiceYaml, map[string]*bintree{}},
		"openvpn-serviceaccount.yaml":    {openvpnOpenvpnServiceaccountYaml, map[string]*bintree{}},
		"server.conf":                    {openvpnServerConf, map[string]*bintree{}},
		"worker":                         {openvpnWorker, map[string]*bintree{}},
	}},
	"registry": {nil, map[string]*bintree{
		"cluster-imageregistry-config.yaml": {registryClusterImageregistryConfigYaml, map[string]*bintree{}},
	}},
	"router-proxy": {nil, map[string]*bintree{
		"client.conf":                           {routerProxyClientConf, map[string]*bintree{}},
		"haproxy.cfg":                           {routerProxyHaproxyCfg, map[string]*bintree{}},
		"router-proxy-configmap.yaml":           {routerProxyRouterProxyConfigmapYaml, map[string]*bintree{}},
		"router-proxy-deployment.yaml":          {routerProxyRouterProxyDeploymentYaml, map[string]*bintree{}},
		"router-proxy-http-service.yaml":        {routerProxyRouterProxyHttpServiceYaml, map[string]*bintree{}},
		"router-proxy-https-service.yaml":       {routerProxyRouterProxyHttpsServiceYaml, map[string]*bintree{}},
		"router-proxy-vpnclient-configmap.yaml": {routerProxyRouterProxyVpnclientConfigmapYaml, map[string]*bintree{}},
		"router-proxy-vpnclient-secret.yaml":    {routerProxyRouterProxyVpnclientSecretYaml, map[string]*bintree{}},
	}},
	"user-manifests-bootstrapper": {nil, map[string]*bintree{
		"user-manifest-template.yaml":          {userManifestsBootstrapperUserManifestTemplateYaml, map[string]*bintree{}},
		"user-manifests-bootstrapper-pod.yaml": {userManifestsBootstrapperUserManifestsBootstrapperPodYaml, map[string]*bintree{}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}
